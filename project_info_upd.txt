–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:
BOT\
| -- data\
|    | -- contexts\
|         | -- 8003749... (–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å Telegram id 8003749...)
|              | -- text\ (—Ç—É—Ç —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤–µ—Å—å —Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –∏–∑–≤–ª–µ—á–µ–Ω –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤)
|              | -- storage\ (—Ç—É—Ç —Ö—Ä–∞–Ω—è—Ç—Å—è —Ä–∞–±–æ—á–∏–µ —Ñ–∞–π–ª—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã RAG)
|              | -- documents\ (—Ç—É—Ç —Ö—Ä–∞–Ω—è—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã)
|
| -- handlers\ (—Ç—É—Ç —Ö—Ä–∞–Ω—è—Ç—Å—è –≤—Å–µ —Ö—ç–Ω–¥–ª–µ—Ä—ã –¥–ª—è —Ç–µ–ª–µ–≥—Ä–∞–º –±–æ—Ç–∞)
|    | -- context.py (—Ç—É—Ç —Ö—ç–Ω–¥–ª–µ—Ä—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤)
|    | -- document.py (—Ç—É—Ç —Ö—ç–Ω–¥–ª–µ—Ä—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤)
|    | -- main_menu.py (—Ç—É—Ç —Ö—ç–Ω–¥–ª–µ—Ä—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é –±–æ—Ç–∞)
|    | -- question.py (—Ç—É—Ç —Ö—ç–Ω–¥–ª–µ—Ä—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤, –ø–æ–∫–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω)
|    | -- start.py (—Ç—É—Ç —Ö—ç–Ω–¥–ª–µ—Ä—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã start)
|
| -- keyboards\ (—Ç—É—Ç —Ö—Ä–∞–Ω—è—Ç—Å—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –º–µ–Ω—é)
|    | -- context_menu.py (–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é)
|    | -- document_menu.py (–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –º–µ–Ω—é –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤)
|    | -- main_menu.py (–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é)
|
| -- moduls\ (–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –≤—Å–æ–ø–æ–≥–∞—Ç–µ–ª—å–Ω—ã—Ö –º–æ–¥—É–ª–µ–π —Å–∏—Å—Ç–µ–º—ã)
|    | -- extract_text.py (–º–æ–¥—É–ª—å –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤)
|    | -- lightrag_module.py (–º–æ–¥—É–ª—å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞ LightRAG)
|
| -- bot.py (–≥–ª–∞–≤–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –ø–æ–¥–Ω—è—Ç–∏—è —Ç–µ–ª–µ–≥—Ä–∞–º –±–æ—Ç–∞)
| -- config.py (–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, –∞–ø–∏ –∫–ª—é—á–∏ –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ)

–ù–∏–∂–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω –∫–æ–¥ —Å–æ –≤—Å–µ—Ö —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –≤—ã—à–µ —Ñ–∞–π–ª–æ–≤. –ü–µ—Ä–µ–¥ –∫–æ–¥–æ–º —É–∫–∞–∑–∞–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞, –∏–∑ –∫–æ—Ç–æ—Ä–æ–≥–æ —ç—Ç–æ—Ç –∫–æ–¥ –≤–∑—è—Ç:
** –§–∞–π–ª handlers\context.py**
import os
import shutil
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.utils.keyboard import InlineKeyboardBuilder, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.types import ReplyKeyboardRemove

from keyboards.main_menu import main_menu
from keyboards.document_menu import document_menu

from config import BASE_STORAGE_DIR, MAX_CONTEXTS

router = Router()

class ContextStates(StatesGroup):
    naming = State()

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
def get_user_contexts(user_id: int):
    user_dir = os.path.join(BASE_STORAGE_DIR, str(user_id))
    if not os.path.exists(user_dir):
        os.makedirs(user_dir)
    return [name for name in os.listdir(user_dir) if os.path.isdir(os.path.join(user_dir, name))]

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
@router.message(F.text.lower() == "üìÇ —Å–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç")
async def create_context(message: Message, state: FSMContext):
    user_id = message.from_user.id
    context = get_user_contexts(user_id)

    if len(context) >= MAX_CONTEXTS:
        await message.answer("–í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤")
        return

    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞:", reply_markup=ReplyKeyboardRemove())
    await state.set_state(ContextStates.naming)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
@router.message(ContextStates.naming)
async def save_context_name(message: Message, state: FSMContext):
    user_id = message.from_user.id
    context_name = message.text.strip()

    user_dir = os.path.join(BASE_STORAGE_DIR, str(user_id))
    context_path = os.path.join(user_dir, context_name)

    storage_path = os.path.join(context_path, "storage")
    txt_path = os.path.join(context_path, "text")
    documents_path = os.path.join(context_path, "documents")

    if os.path.exists(context_path):
        await message.answer("–ö–æ–Ω—Ç–µ–∫—Å—Ç —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–µ.")
        return

    os.makedirs(storage_path, exist_ok=True)
    os.makedirs(documents_path, exist_ok=True)
    os.makedirs(txt_path, exist_ok=True)
    await state.clear()

    await message.answer(f"–ö–æ–Ω—Ç–µ–∫—Å—Ç '{context_name}' —Å–æ–∑–¥–∞–Ω!", reply_markup=main_menu)


# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
@router.message(F.text.lower() == "üìã —Å–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤")
async def list_contexts(message: Message):
    user_id = message.from_user.id
    contexts = get_user_contexts(user_id)
    if not contexts:
        await message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤.")
        return

    keyboard = InlineKeyboardBuilder()
    for context in contexts:
        keyboard.button(text=context, callback_data=f"select_{context}")

    await message.answer("–í–∞—à–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã:", reply_markup=keyboard.as_markup())

@router.callback_query(F.data.startswith("select_"))
async def select_context(callback: CallbackQuery, state: FSMContext):
    context_name = callback.data.split("_", 1)[1]
    await state.update_data(current_context=context_name) # —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏

    await callback.message.answer(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç: {context_name}", reply_markup=document_menu)

# –£–¥–∞–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
@router.message(F.text.lower() == "üóë —É–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç")
async def delete_context(message: Message, state: FSMContext):
    user_id = message.from_user.id
    contexts = get_user_contexts(user_id)

    if not contexts:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤.")
        return

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=context, callback_data=f"delete_ctx_{context}")]
            for context in contexts
        ]
    )

    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å:", reply_markup=keyboard)

@router.callback_query(F.data.startswith("delete_ctx_"))
async def confirm_delete_context(callback: CallbackQuery, state: FSMContext):
    context_name = callback.data.replace("delete_ctx_", "", 1)

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"confirm_delete_ctx_{context_name}")],
            [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_delete")]
        ]
    )

    # –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π (–µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ)
    try:
        await callback.message.delete()
    except Exception:
        pass  # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å, –ø—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    await callback.message.answer(
        f"–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç '{context_name}'? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ!",
        reply_markup=keyboard
    )


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —É–¥–∞–ª–µ–Ω–∏—è
@router.callback_query(F.data.startswith("confirm_delete_ctx_"))
async def delete_context_confirmed(callback: CallbackQuery, state: FSMContext):
    user_id = callback.from_user.id
    context_name = callback.data.split("_", 3)[3]
    context_path = os.path.join(BASE_STORAGE_DIR, str(user_id), context_name)

    try:
        await callback.message.delete()
    except Exception:
        pass  # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å, –ø—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º

    if os.path.exists(context_path):
        shutil.rmtree(context_path)  # –ü–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª—è–µ–º –ø–∞–ø–∫—É –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        await callback.message.answer(f"‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç '{context_name}' –±—ã–ª —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω.")
    else:
        await callback.message.answer(f"‚ö† –ö–æ–Ω—Ç–µ–∫—Å—Ç '{context_name}' —É–∂–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")

    await callback.answer()  # –ó–∞–∫—Ä—ã—Ç—å –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ


# –û—Ç–º–µ–Ω–∞ —É–¥–∞–ª–µ–Ω–∏—è
@router.callback_query(F.data == "cancel_delete")
async def cancel_delete(callback: CallbackQuery):
    await callback.message.answer("–£–¥–∞–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    await callback.answer()


** –§–∞–π–ª handlers\document.py**
import os
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, ReplyKeyboardRemove
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.utils.keyboard import InlineKeyboardBuilder

from moduls.lightrag_module import build_rag
from moduls.extract_text import process_document
from keyboards.document_menu import document_menu

import datetime

from config import BASE_STORAGE_DIR

import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

router = Router()

class DocumentStates(StatesGroup):
    waiting_for_document = State()
    proccessing_document = State()
    choosing_document_to_delete = State()

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
def get_documents_list(user_id: int, context_name: str):
    document_path = os.path.join(BASE_STORAGE_DIR, str(user_id), context_name, "documents")
    if not os.path.exists(document_path):
        return []

    documents = []
    for file_name in os.listdir(document_path):
        file_path = os.path.join(document_path, file_name)
        if os.path.isfile(file_path):
            file_size = os.path.getsize(file_path) // 1024 # –†–∞–∑–º–µ—Ä –≤ –ö–ë
            file_extension = os.path.splitext(file_name)[1]
            file_mtime = datetime.datetime.fromtimestamp(os.path.getmtime(file_path)).strftime("%Y-%m-%d %H:%M")

            documents.append({
                "name": file_name,
                "extension": file_extension,
                "size_kb": file_size,
                "uploaded_at": file_mtime
            })

    return documents

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞
@router.message(F.text.lower() == "–∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã")
async def upload_document_request(message: Message, state: FSMContext):
    user_data = await state.get_data()
    current_context = user_data.get("current_context")

    if not current_context:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤ —Ä–∞–∑–¥–µ–ª–µ '–°–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤'.")
        return

    await message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç.", reply_markup=ReplyKeyboardRemove())
    await state.set_state(DocumentStates.waiting_for_document)


# —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–æ–∫–æ–≤
async def processing_uploaded_docs(message: Message, state: FSMContext):
    await message.answer("‚è≥–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤...")

    user_id = message.from_user.id
    user_data = await state.get_data()
    current_context = user_data.get('current_context')

    user_storage_path = os.path.join(BASE_STORAGE_DIR, str(user_id), current_context, "storage")
    user_txt_path = os.path.join(BASE_STORAGE_DIR, str(user_id), current_context, "text")
    user_documents_path = os.path.join(BASE_STORAGE_DIR, str(user_id), current_context, "documents")

    # --- 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è RAG ---
    rag = None
    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º await –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ build_rag
        rag = await build_rag(user_storage_path)
        logging.info(f"Successfully created/initialized RAG for context {current_context} of user {user_id}")
    except Exception as e:
        # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        logging.exception(f"An exception occurred while creating RAG for context {current_context} of user {user_id}: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–∏—Å—Ç–µ–º—ã RAG üòî")
        return False # –°–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ–± –æ—à–∏–±–∫–µ

    # –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ RAG —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
    if rag is None:
         logging.error(f"RAG object is None after initialization for context {current_context}, user {user_id}.")
         await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å RAG. –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –ø—Ä–µ—Ä–≤–∞–Ω–∞.")
         return False # –°–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ–± –æ—à–∏–±–∫–µ

    for filename in os.listdir(user_documents_path):
        await message.answer(f"‚è≥ –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ {filename.split('/')[-1]}")
        try:
          name_of_file = filename.split('.')[0]
          txt_file_path = os.path.join(user_txt_path, f"{name_of_file}.txt")
          logging.info(f"TXT file path: {txt_file_path}")
          if not os.path.isfile(txt_file_path):
              extracted_text = process_document(os.path.join(user_documents_path, filename))
              logging.info(f"Extract text from file {filename.split('/')[-1]}")
              #print(extracted_text)
              with open(txt_file_path, 'w', encoding="utf-8") as txt_out_file:
                  txt_out_file.write(extracted_text)
              await message.answer(f"‚úÖ –¢–µ–∫—Å—Ç –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ {filename.split('/')[-1]} –∏–∑–≤–ª–µ—á–µ–Ω!")
              await message.answer(f"‚è≥ –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ {filename.split('/')[-1]} –≤ RAG...")
              logging.info(f"Adding text from file {filename.split('/')[-1]} to the RAG")
              try:
                with open(txt_file_path) as read_file:
                    await rag.ainsert(read_file.read())
                logging.info(f"Text from file {filename.split('/')[-1]} was added to the RAG")
                await message.answer(f"‚úÖ –î–∞–Ω–Ω—ã–µ –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ {filename.split('/')[-1]} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ RAG!")
              except Exception as e:
                logging.info(f"An exception was occured while adding text from file {filename} to the RAG: {e}")
                await message.answer(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ {filename.split('/')[-1]} –≤ RAG üòî")
          else:
              continue
        except Exception as e:
          print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞ –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ {filename}: {repr(e)}")
          await message.answer(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞ –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ {filename.split('/')[-1]} üòî")
          continue

    await message.answer("–î–æ–∫—É–º–µ–Ω—Ç—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã!", reply_markup=document_menu)


# –•–µ–Ω–¥–ª–µ—Ä –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞
@router.message(DocumentStates.waiting_for_document, F.document)
async def save_uploaded_document(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user_data = await state.get_data()
    current_context = user_data.get('current_context')

    if not current_context:
        await message.answer("–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω —Ç–µ–∫—É—â–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç. –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç –∑–∞–Ω–æ–≤–æ.")
        return

    document = message.document
    user_documents_path = os.path.join(BASE_STORAGE_DIR, str(user_id), current_context, "documents")
    user_txt_path = os.path.join(BASE_STORAGE_DIR, str(user_id), current_context, "txt")

    if not os.path.exists(user_documents_path):
        os.makedirs(user_documents_path)
        os.makedirs(user_txt_path)

    sanitized_filename = document.file_name.replace(' ', '_')
    document_path = os.path.join(user_documents_path, sanitized_filename)

    # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –≤ –§–°
    file = await message.bot.get_file(document.file_id)
    await message.bot.download_file(file.file_path, document_path)

    await message.answer(f"‚úÖ –î–æ–∫—É–º–µ–Ω—Ç '{sanitized_filename}' —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç '{current_context}'!")
    await processing_uploaded_docs(message, state)


# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
@router.message(F.text.lower() == "—É–¥–∞–ª–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã")
async def ask_document_for_deletion(message: Message, state: FSMContext):
    user_data = await state.get_data()
    current_context = user_data.get("current_context")

    if not current_context:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤ —Ä–∞–∑–¥–µ–ª–µ '–°–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤'.")
        return

    user_id = message.from_user.id
    documents = get_documents_list(user_id, current_context)

    if not documents:
        await message.answer(f"–í –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ '{current_context}' –Ω–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return

    keyboard = InlineKeyboardBuilder()
    for doc in documents:
        keyboard.button(text=doc['name'], callback_data=f"delete_{doc['name']}")
    keyboard.adjust(1)

    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç, –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=keyboard.as_markup())

# –•–µ–Ω–¥–ª–µ—Ä –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —É–¥–∞–ª–µ–Ω–∏—è
@router.callback_query(F.data.startswith("delete_"))
async def confirm_deletion(callback: CallbackQuery, state: FSMContext):
    user_data = await state.get_data()
    current_context = user_data.get("current_context")
    document_name = callback.data.split("_", 1)[1]

    keyboard = InlineKeyboardBuilder()
    keyboard.button(text="‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"confirm_delete_{document_name}")
    keyboard.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_delete")

    await callback.message.answer(f"–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å '{document_name}'?", reply_markup=keyboard.as_markup())

# –•–µ–Ω–¥–ª–µ—Ä –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞
@router.callback_query(F.data.startswith("confirm_delete_"))
async def delete_document(callback: CallbackQuery, state: FSMContext):
    user_data = await state.get_data()
    current_context = user_data.get("current_context")
    document_name = callback.data.split("_", 2)[2]

    user_id = callback.from_user.id
    document_path = os.path.join(BASE_STORAGE_DIR, str(user_id), current_context, "documents", document_name)

    if os.path.exists(document_path):
        os.remove(document_path)
        await callback.message.answer(f"‚úÖ –§–∞–π–ª '{document_name}' —É–¥–∞–ª—ë–Ω.")
    else:
        await callback.message.answer(f"‚ö† –§–∞–π–ª '{document_name}' —É–∂–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.")

# –•–µ–Ω–¥–ª–µ—Ä –¥–ª—è –æ—Ç–º–µ–Ω—ã —É–¥–∞–ª–µ–Ω–∏—è
@router.callback_query(F.data == "cancel_delete")
async def cancel_delete(callback: CallbackQuery):
    await callback.message.answer("–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")

# –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
@router.message(F.text.lower() == "–ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã")
async def list_documents(message: Message, state: FSMContext):
    user_data = await state.get_data()
    current_context = user_data.get("current_context")

    if not current_context:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤ —Ä–∞–∑–¥–µ–ª–µ '–°–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤'.")
        return

    user_id = message.from_user.id
    documents = get_documents_list(user_id, current_context)

    if len(documents) == 0:
        await message.answer(f"–í –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ '{current_context}' –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤.")
        return

    doc_list_message = f"üìÇ **–î–æ–∫—É–º–µ–Ω—Ç—ã –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ '{current_context}':**\n\n"
    for doc in documents:
        doc_list_message += (f"üìÑ **{doc['name']}**\n"
                             f"  ‚îú üóÇ –§–æ—Ä–º–∞—Ç: {doc['extension']}\n"
                             f"  ‚îú üìè –†–∞–∑–º–µ—Ä: {doc['size_kb']} –ö–ë\n"
                             f"  ‚îî üïí –î–∞—Ç–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {doc['uploaded_at']}\n\n")

    await message.answer(doc_list_message)


** –§–∞–π–ª handlers\main_menu.py**
from aiogram import Router, F
from aiogram.types import Message
from keyboards.main_menu import main_menu

router = Router()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /menu
@router.message(F.text.lower() == "–º–µ–Ω—é")
async def show_main_menu(message: Message):
    await message.answer("üîπ **–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é** üîπ\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–û –±–æ—Ç–µ"
@router.message(F.text.lower() == "‚Ñπ –æ –±–æ—Ç–µ")
async def about_bot(message: Message):
    bot_info = (
        "ü§ñ –û –±–æ—Ç–µ\n\n"
        "–≠—Ç–æ—Ç –±–æ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—É—é –∫–æ–Ω—Å—É–ª—å—Ç–∏—Ä—É—é—â—É—é —Å–∏—Å—Ç–µ–º—É, –∫–æ—Ç–æ—Ä–∞—è –±–µ—Ä–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤.\n"
        "–û–Ω —Å–æ–∑–¥–∞–Ω –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —Å –±–æ–ª—å—à–∏–º–∏ –º–∞—Å—Å–∏–≤–∞–º–∏ —Ç–µ–∫—Å—Ç–æ–≤–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, —É–º–µ–Ω—å—à–µ–Ω–∏—è –º–æ–Ω–æ—Ç–æ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã –ø–æ –ø–æ–∏—Å–∫—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö –∏ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –Ω–∏–º–∏.\n\n"
        "üìå –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:\n"
        "   üîπüìÇ –°–æ–∑–¥–∞–Ω–∏–µ –∏ üóë —É–¥–∞–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤: –ö–æ–Ω—Ç–µ–∫—Å—Ç - —ç—Ç–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ, –≥–¥–µ —Ö—Ä–∞–Ω—è—Ç—Å—è —Å–≤—è–∑–∞–Ω–Ω—ã–µ –º–µ–∂–¥—É —Å–æ–±–æ–π –¥–æ–∫—É–º–µ–Ω—Ç—ã. –í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∂–∞—Ç—å —Ñ–∞–π–ª—ã, —É–ø—Ä–∞–≤–ª—è—Ç—å –∏–º–∏ –∏ –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã –ø–æ –∏—Ö —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É\n"
        "   üîπ–ó–∞–≥—Ä—É–∑–∫–∞ –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤\n: –í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∂–∞—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤–∞—à–∏—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤.\n"
        "   üîπ–ó–∞–¥–∞–Ω–∏–µ –≤–æ–ø—Ä–æ—Å–æ–≤ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ: –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –Ω–µ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞–≤–∞—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤.\n\n"
        "üë®‚Äçüíª –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫: @lil_psina"
    )
    await message.answer(bot_info)

** –§–∞–π–ª handlers\question.py**
import os
import logging
from aiogram import Router, F
from aiogram.types import KeyboardButton, Message, ReplyKeyboardMarkup, ReplyKeyboardRemove
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

from lightrag import QueryParam

from moduls.lightrag_module import build_rag
from config import BASE_STORAGE_DIR
from keyboards.document_menu import document_menu
from keyboards.main_menu import main_menu

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

router = Router()

VALID_QUERY_MODES = ["naive", "local", "global", "hybrid", "mix"]

back_keyboard = ReplyKeyboardMarkup(
  keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]],
  resize_keyboard=True
)

class QuestionStates(StatesGroup):
  asking_questions_in_context = State()

@router.message(F.text.lower() == "–∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å")
async def ask_for_question(message: Message, state: FSMContext):
  user_data = await state.get_data()
  current_context = user_data.get("current_context")

  if not current_context:
    await message.answer("‚ùóÔ∏è –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤ —Ä–∞–∑–¥–µ–ª–µ 'üìã –°–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤'.")
    return

  await message.answer(
    f"üîπ –í—ã –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ: **{current_context}**\n\n"
    f"–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –∏ —Ä–µ–∂–∏–º —á–µ—Ä–µ–∑ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å ' | '.\n\n"
    f"–í–ê–ñ–ù–û: –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏–º–≤–æ–ª ' | ' –≤ –∑–∞–ø—Ä–æ—Å–µ, –æ–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¢–û–õ–¨–ö–û –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞ –∏ —Ä–µ–∂–∏–º–∞."
    f"**–§–æ—Ä–º–∞—Ç:** `–í–∞—à –≤–æ–ø—Ä–æ—Å | —Ä–µ–∂–∏–º`\n\n"
    f"**–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–µ–∂–∏–º—ã:**\n"
    f" ‚Ä¢ `naive` - –ü—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫ –ø–æ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤–µ–∫—Ç–æ—Ä–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ).\n"
    f" ‚Ä¢ `local` - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –ª–æ–∫–∞–ª—å–Ω—ã–µ —Å—É—â–Ω–æ—Å—Ç–∏ –∏ —Å–≤—è–∑–∏ –≥—Ä–∞—Ñ–∞ –∑–Ω–∞–Ω–∏–π.\n"
    f" ‚Ä¢ `global` - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–µ —Å—É—â–Ω–æ—Å—Ç–∏ –∏ —Å–≤—è–∑–∏  –≥—Ä–∞—Ñ–∞ –∑–Ω–∞–Ω–∏–π.\n"
    f" ‚Ä¢ `hybrid` - –ö–æ–º–±–∏–Ω–∞—Ü–∏—è local –∏ global.\n\n"
    f" ‚Ä¢ `mix` - –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –∏ –≥—Ä–∞—Ñ–∞ –∑–Ω–∞–Ω–∏–π.\n\n"
    f"*–ü—Ä–∏–º–µ—Ä:* `–ö–∞–∫–æ–≤—ã –æ—Å–Ω–æ–≤–Ω—ã–µ –≤—ã–≤–æ–¥—ã –¥–æ–∫—É–º–µ–Ω—Ç–∞? | naive`",
    reply_markup=back_keyboard, # –£–±–∏—Ä–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É document_menu
    parse_mode="Markdown" # –ò—Å–ø–æ–ª—å–∑—É–µ–º Markdown –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
  )
  await state.set_state(QuestionStates.asking_questions_in_context)


@router.message(QuestionStates.asking_questions_in_context)
async def process_rag_question(message: Message, state: FSMContext):
  user_data = await state.get_data()
  current_context = user_data.get("current_context")
  user_id = message.from_user.id
  if message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
         await handle_back_button(message, state) # –ú–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –¥—Ä—É–≥–æ–π —Ö–µ–Ω–¥–ª–µ—Ä
         return

  if not current_context:
    await message.answer("‚ùóÔ∏è –û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω —Ç–µ–∫—É—â–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –µ–≥–æ —Å–Ω–æ–≤–∞.")
    await state.clear()
    await message.answer("–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=main_menu)
    return

  user_input = message.text.strip()
  parts = user_input.split("|", 1)

  if len(parts) != 2:
    await message.answer(
      f"‚ùóÔ∏è **–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞.** –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–æ–ø—Ä–æ—Å –∏ —Ä–µ–∂–∏–º, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–µ ' | ', –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É '‚¨ÖÔ∏è –ù–∞–∑–∞–¥'\n\n"
      f"**–ü—Ä–∏–º–µ—Ä:** `–¢–µ–∫—Å—Ç –≤–∞—à–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ | naive`"
    )
    return

  question_text = parts[0].strip()
  query_mode = parts[1].strip().lower()

  if not question_text:
    await message.answer("‚ùóÔ∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞.")
    return

  if query_mode not in VALID_QUERY_MODES:
    await message.answer(
      f"‚ùóÔ∏è **–ù–µ–≤–µ—Ä–Ω—ã–π —Ä–µ–∂–∏–º:** `{query_mode}`.\n\n"
      f"–î–æ–ø—É—Å—Ç–∏–º—ã–µ —Ä–µ–∂–∏–º—ã: {', '.join(VALID_QUERY_MODES)}."
    )
    return

  await message.answer("‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞...")
  logging.info(f"User {user_id} asked in context '{current_context}': '{question_text}' with mode '{query_mode}'")

  storage_dir = os.path.join(BASE_STORAGE_DIR, str(user_id), current_context, "storage")
  rag = None
  try:
    rag = await build_rag(storage_dir)
    logging.info(f"RAG initialized seccessfuly for context '{current_context}' for user {user_id}")
  except Exception as e:
    logging.exception(f"Failed to initialize RAG for context '{current_context}' (User: {user_id}: {e})")
    await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å RAG –¥–ª—è —ç—Ç–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    await state.clear()
    await message.answer("–ó–∞–ø—Ä–æ—Å –æ—Ç–º–µ–Ω–µ–Ω.", reply_markup=document_menu)
    return

  try:
    response = await rag.aquery(question_text, param=QueryParam(mode=query_mode))
    if response:
      logging.info(f"Succsessfuly got answer for user {user_id} in context '{current_context}'")
      await message.answer(f"üí° **–û—Ç–≤–µ—Ç:**\n\n{response}")
    else:
      logging.warning(f"RAG returned no answer or unexpected structure for user {user_id} in context '{current_context}'. Response: {response}")
      await message.answer("üòï –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç —Å–∏—Å—Ç–µ–º—ã. –í–æ–∑–º–æ–∂–Ω–æ, –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.")

  except Exception as e:
    logging.exception(f"Error during RAG query for context '{current_context}' (User: {user_id}): {e}")
    await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –∫ RAG.")

  finally:
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚¨ÖÔ∏è –ù–∞–∑–∞–¥'.")

@router.message(QuestionStates.asking_questions_in_context, F.text.lower() == "‚¨ÖÔ∏è –Ω–∞–∑–∞–¥")
async def handle_back_button(message: Message, state: FSMContext):
    user_data = await state.get_data()
    current_context = user_data.get("current_context", "—Ç–µ–∫—É—â–∏–π") # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è

    logging.info(f"User {message.from_user.id} exited question mode for context '{current_context}'.")
    #await state.clear() # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    await message.answer(
        f"–í—ã –≤—ã—à–ª–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ –∑–∞–¥–∞–Ω–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ '{current_context}'.",
        reply_markup=document_menu # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –º–µ–Ω—é –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
    )

** –§–∞–π–ª handlers\start.py**
from aiogram import Router, types
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

router = Router()

@router.message(Command("start"))
async def start_command(message: types.Message):
    keyboard = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üìÇ –°–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç")]],
        resize_keyboard=True
    )
    await message.answer("–ü—Ä–∏–≤–µ—Ç! –Ø –≤–∞—à –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç. –î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω–µ–º —Å —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞!", reply_markup=keyboard)

** –§–∞–π–ª keyboards\context_menu.py**
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

def get_context_menu(contexts: list) -> ReplyKeyboardMarkup:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –º–µ–Ω—é —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞–º–∏.
    :param contexts: –°–ø–∏—Å–æ–∫ –Ω–∞–∑–≤–∞–Ω–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤.
    :return: –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤.
    """
    buttons = [[KeyboardButton(text=context)] for context in contexts]
    buttons.append([KeyboardButton(text="üîô –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")])

    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True
    )

** –§–∞–π–ª keyboards\document_menu.py**
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

document_menu = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="–ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å")],
                  [KeyboardButton(text="–ó–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã")],
                  [KeyboardButton(text="–£–¥–∞–ª–∏—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã")],
                  [KeyboardButton(text="–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã")],
                  [KeyboardButton(text="–ú–µ–Ω—é")]],
        resize_keyboard=True
    )

** –§–∞–π–ª keyboards\main_menu.py**
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

main_menu = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìÇ –°–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç")],
        [KeyboardButton(text="üìã –°–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤")],
        [KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç")],
        [KeyboardButton(text="‚Ñπ –û –±–æ—Ç–µ")]
    ],
    resize_keyboard=True
)

** –§–∞–π–ª moduls\extract_text.py**
import fitz
import docx
import subprocess
import os
import tempfile
import logging
from pathlib import Path
from typing import Optional, List, Tuple

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ---
def _convert_table_to_markdown(table: docx.table.Table) -> str:
    """–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü—ã docx –≤ Markdown"""
    md_table = ""
    # –ó–∞–≥–æ–ª–æ–≤–∫–∏
    header_cells = [cell.text.strip().replace("|", "\\|") for cell in table.rows[0].cells]
    md_table += "| " + " | ".join(header_cells) + " |\n"
    # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
    md_table += "| " + " | ".join(["---"] * len(header_cells)) + " |\n"
    # –°—Ç—Ä–æ–∫–∏ –¥–∞–Ω–Ω—ã—Ö
    for row in table.rows[1:]:
        row_cells = [cell.text.strip().replace("|", "\\|") for cell in row.cells]
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ (–µ—Å–ª–∏ –≤—Å–µ —è—á–µ–π–∫–∏ –ø—É—Å—Ç—ã–µ)
        if any(row_cells):
            md_table += "| " + " | ".join(row_cells) + " |\n"
    return md_table

def _is_block_inside_bbox(block_bbox: fitz.Rect, table_bboxes: List[fitz.Rect]) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –±–ª–æ–∫ (–ø–æ –µ–≥–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º)
    –≤–Ω—É—Ç—Ä–∏ –∫–∞–∫–æ–π-–ª–∏–±–æ –∏–∑ –≥—Ä–∞–Ω–∏—Ü —Ç–∞–±–ª–∏—Ü.
    """
    for table_bbox in table_bboxes:
        # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Ç–∞–±–ª–∏—Ü—ã –¥–∞–Ω–Ω—ã–π –±–ª–æ–∫.
        # –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ (intersects)
        # –∏–ª–∏ –ø—Ä–æ—Ü–µ–Ω—Ç –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏—è, –µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è.
        if table_bbox.contains(block_bbox):
            return True
    return False

def _convert_extracted_table_to_markdown(data: list[list]) -> str:
    """
    –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã (—Å–ø–∏—Å–æ–∫ —Å–ø–∏—Å–∫–æ–≤) –≤ —Å—Ç—Ä–æ–∫—É Markdown.
    """
    if not data:
        return ""

    # –û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö: –∑–∞–º–µ–Ω–∞ None –Ω–∞ –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É, —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ "|"
    cleaned_data = []
    num_cols = 0
    for row_idx, row in enumerate(data):
        # PyMuPDF –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å None –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Å—Ç—Ä–æ–∫ –∏–ª–∏ —è—á–µ–µ–∫
        if row is None: continue

        current_row = []
        # –ò–Ω–æ–≥–¥–∞ table.extract() –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–µ-—Å–ø–∏—Å–∫–æ–≤ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞, –æ–±—Ä–∞–±–æ—Ç–∞–µ–º —ç—Ç–æ
        if not isinstance(row, (list, tuple)):
             row = [row] # –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ —Å–ø–∏—Å–æ–∫, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ —Å–ø–∏—Å–æ–∫

        for cell in row:
            # –ó–∞–º–µ–Ω—è–µ–º –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫ –≤–Ω—É—Ç—Ä–∏ —è—á–µ–π–∫–∏ –Ω–∞ –ø—Ä–æ–±–µ–ª –∏–ª–∏ <br> –¥–ª—è Markdown
            cell_text = str(cell).replace('\r', '').replace('\n', ' ').replace("|", "\\|").strip() if cell is not None else ""
            current_row.append(cell_text)

        cleaned_data.append(current_row)
        num_cols = max(num_cols, len(current_row))

    if not cleaned_data or num_cols == 0:
        return ""

    # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–æ–ª–±—Ü–æ–≤
    # –≠—Ç–æ –≤–∞–∂–Ω–æ –¥–ª—è –≤–∞–ª–∏–¥–Ω–æ–≥–æ Markdown
    for row in cleaned_data:
        row.extend([""] * (num_cols - len(row)))

    md_table_lines = []
    # –ó–∞–≥–æ–ª–æ–≤–æ–∫ (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ - —ç—Ç–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫)
    header = cleaned_data[0]
    md_table_lines.append("| " + " | ".join(header) + " |")
    # –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
    md_table_lines.append("| " + " | ".join(["---"] * num_cols) + " |")
    # –¢–µ–ª–æ —Ç–∞–±–ª–∏—Ü—ã
    for row in cleaned_data[1:]:
        md_table_lines.append("| " + " | ".join(row) + " |")

    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–∞–±–ª–∏—Ü—É —Å –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π –ø–æ—Å–ª–µ –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
    return "\n".join(md_table_lines) + "\n"

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ PDF ---

def extract_markdown_from_pdf_with_tables(pdf_path: str) -> str:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—Å—Ç –∏–∑ PDF –≤ Markdown, –∏—Å–ø–æ–ª—å–∑—É—è page.find_tables()
    –¥–ª—è —è–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–∞–±–ª–∏—Ü –∏ page.get_text("blocks") –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.
    """
    final_markdown_content = ""
    try:
        doc = fitz.open(pdf_path)
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            page_elements = [] # –°–ø–∏—Å–æ–∫ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –±–ª–æ–∫–æ–≤ –∏ Markdown —Ç–∞–±–ª–∏—Ü

            # 1. –ù–∞–π—Ç–∏ —Ç–∞–±–ª–∏—Ü—ã –∏ –∏—Ö –≥—Ä–∞–Ω–∏—Ü—ã
            # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ find_tables –º–æ–∂–Ω–æ —Ç—é–Ω–∏–Ω–≥–æ–≤–∞—Ç—å (strategy, vertical_strategy –∏ —Ç.–¥.)
            # https://pymupdf.readthedocs.io/en/latest/page.html#Page.find_tables
            tabs = page.find_tables(snap_tolerance=3, join_tolerance=3)
            table_bboxes = [fitz.Rect(t.bbox) for t in tabs.tables]
            logging.info(f"Page {page_num + 1}: Found {len(tabs.tables)} table(s).")

            # 2. –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –æ—Ç—Ä–µ–Ω–¥–µ—Ä–∏—Ç—å —Ç–∞–±–ª–∏—Ü—ã –≤ Markdown
            rendered_tables = {} # –°–ª–æ–≤–∞—Ä—å {–∏–Ω–¥–µ–∫—Å_—Ç–∞–±–ª–∏—Ü—ã: —Å—Ç—Ä–æ–∫–∞_markdown}
            table_insertion_points = {} # –°–ª–æ–≤–∞—Ä—å {–∏–Ω–¥–µ–∫—Å_—Ç–∞–±–ª–∏—Ü—ã: –≤–µ—Ä—Ö–Ω—è—è_–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞_y}
            for i, table in enumerate(tabs.tables):
                table_data = table.extract()
                if table_data: # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –∏–∑–≤–ª–µ–∫–ª–∏—Å—å –¥–∞–Ω–Ω—ã–µ
                    md_table = _convert_extracted_table_to_markdown(table_data)
                    if md_table: # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ Markdown –Ω–µ –ø—É—Å—Ç–æ–π
                        rendered_tables[i] = md_table
                        table_insertion_points[i] = fitz.Rect(table.bbox).y0 # y0 - –≤–µ—Ä—Ö–Ω—è—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞

            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏–Ω–¥–µ–∫—Å—ã —Ç–∞–±–ª–∏—Ü –ø–æ –∏—Ö –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–º—É –ø–æ–ª–æ–∂–µ–Ω–∏—é
            sorted_table_indices = sorted(table_insertion_points, key=table_insertion_points.get)
            yielded_tables = {idx: False for idx in sorted_table_indices} # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã

            # 3. –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –±–ª–æ–∫–∏
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º "blocks" –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
            # sort=True —É–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–µ—Ç –±–ª–æ–∫–∏ –ø–æ y, –∑–∞—Ç–µ–º –ø–æ x (–ø–æ—Ä—è–¥–æ–∫ —á—Ç–µ–Ω–∏—è)
            blocks = page.get_text("blocks", sort=True)

            last_y_pos = 0 # –î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –≤—Å—Ç–∞–≤–∫–∏ —Ç–∞–±–ª–∏—Ü

            # 4. –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –±–ª–æ–∫–∏ –∏ –≤—Å—Ç–∞–≤–∏—Ç—å —Ç–∞–±–ª–∏—Ü—ã
            for block in blocks:
                block_bbox = fitz.Rect(block[:4]) # –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –±–ª–æ–∫–∞ (x0, y0, x1, y1)
                block_text = block[4].strip()     # –¢–µ–∫—Å—Ç –±–ª–æ–∫–∞
                block_top_y = block_bbox.y0       # –í–µ—Ä—Ö–Ω—è—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –±–ª–æ–∫–∞

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –≤—Å—Ç–∞–≤–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É –ü–ï–†–ï–î —ç—Ç–∏–º –±–ª–æ–∫–æ–º
                for table_idx in sorted_table_indices:
                    # –ï—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –µ—â–µ –Ω–µ –≤—Å—Ç–∞–≤–ª–µ–Ω–∞ –∏ –µ–µ –≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≤—ã—à–µ –∏–ª–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ —Ç–µ–∫—É—â–µ–≥–æ –±–ª–æ–∫–∞
                    if not yielded_tables[table_idx] and table_insertion_points[table_idx] <= block_top_y:
                         # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ–±—ã –Ω–µ –≤—Å—Ç–∞–≤–ª—è—Ç—å —Ç–∞–±–ª–∏—Ü—ã —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –¥—Ä—É–≥ –∫ –¥—Ä—É–≥—É
                         # –∏–ª–∏ –ø–µ—Ä–µ–¥ –±–ª–æ–∫–æ–º, –∫–æ—Ç–æ—Ä—ã–π —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ç–∞–±–ª–∏—Ü—ã.
                         # –ü–æ—Ä–æ–≥ (-5) –º–æ–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å.
                         if table_insertion_points[table_idx] >= last_y_pos - 5:
                            page_elements.append(rendered_tables[table_idx])
                            yielded_tables[table_idx] = True
                            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é, —á—Ç–æ–±—ã —Å–ª–µ–¥—É—é—â–∞—è —Ç–∞–±–ª–∏—Ü–∞/—Ç–µ–∫—Å—Ç –≤—Å—Ç–∞–≤–ª—è–ª–∏—Å—å –ø–æ—Å–ª–µ —ç—Ç–æ–π —Ç–∞–±–ª–∏—Ü—ã
                            last_y_pos = max(last_y_pos, fitz.Rect(tabs.tables[table_idx].bbox).y1)


                # 5. –î–æ–±–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –±–ª–æ–∫–∞, –µ—Å–ª–∏ –æ–Ω –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é —Ç–∞–±–ª–∏—Ü—ã
                if block_text and not _is_block_inside_bbox(block_bbox, table_bboxes):
                    page_elements.append(block_text)
                    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø–æ—Å–ª–µ–¥–Ω–∏–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–≤—ã–º –±–ª–æ–∫–æ–º
                    last_y_pos = max(last_y_pos, block_bbox.y1)

            # 6. –í—Å—Ç–∞–≤–∏—Ç—å –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Ç–∞–±–ª–∏—Ü—ã (–µ—Å–ª–∏ –æ–Ω–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã)
            for table_idx in sorted_table_indices:
                if not yielded_tables[table_idx]:
                    page_elements.append(rendered_tables[table_idx])

            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É Markdown
            final_markdown_content += "\n\n".join(page_elements) + "\n\n" # –î–≤–æ–π–Ω–æ–π –ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏ –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏

        doc.close()
        logging.info(f"Successfully extracted Markdown with explicit tables from PDF: {pdf_path}")
        # –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –æ—Ç –ª–∏—à–Ω–∏—Ö –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫
        final_markdown_content = "\n".join(line for line in final_markdown_content.splitlines() if line.strip())
        return final_markdown_content

    except Exception as e:
        logging.error(f"Error processing PDF file {pdf_path} with table extraction: {e}")
        # –ú–æ–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É –∏–ª–∏ None, –∏–ª–∏ –ø–µ—Ä–µ–≤—ã–±—Ä–æ—Å–∏—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
        # raise e
        return "" # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É –ø—Ä–∏ –æ—à–∏–±–∫–µ

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ DOCX ---

def extract_markdown_from_docx(docx_path: str) -> str:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—Å—Ç –∏–∑ DOCX –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –µ–≥–æ –≤ markdown.
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–∞—Ä–∞–≥—Ä–∞—Ñ—ã –∏ —Ç–∞–±–ª–∏—Ü—ã.
    """

    markdown_elements = []
    try:
        doc = docx.Document(docx_path)
        for element in doc.element.body:
            if isinstance(element, docx.oxml.text.paragraph.CT_P):
                para = docx.text.paragraph.Paragraph(element, doc)
                if para.text.strip(): # –î–æ–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–ø—É—Å—Ç—ã–µ –ø–∞—Ä–∞–≥—Ä–∞—Ñ—ã
                    level = int(para.style.name[-1]) if para.style.name[-1].isdigit() else 1
                    markdown_elements.append(f"{'#' * level} {para.text.strip()}")
                else:
                    markdown_elements.append(para.text.strip())
            elif isinstance(element, docx.oxml.table.CT_Tbl):
                table = docx.table.Table(element, doc)
                if table.rows:
                    markdown_elements.append(_convert_table_to_markdown(table))

        logging.info(f"Successfully extracted Markdown from DOCX: {docx_path}")
        return "\n\n".join(markdown_elements)
    except Exception as e:
        logging.error(f"Error processing DOCX file {docx_path}: {e}")
        raise

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ DOC ---

def convert_doc_to_docx(doc_path: str, output_dir: str) -> Optional[str]:
    """
    –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç DOC –≤ DOCX —Å –ø–æ–º–æ—â—å—é LibreOffice/soffice.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Å–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º—É —Ñ–∞–π–ª—É –∏–ª–∏ None –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏.
    """
    if not Path(doc_path).exists():
         logging.error(f"DOC file not found: {doc_path}")
         return None

    try:
        # –ò–º—è –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –±—É–¥–µ—Ç —Ç–∞–∫–∏–º –∂–µ, –Ω–æ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º .docx
        output_filename = Path(doc_path).stem + ".docx"
        output_path = Path(output_dir) / output_filename

        # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
        # –ü—É—Ç—å –∫ soffice –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è –≤ –≤–∞—à–µ–π —Å–∏—Å—Ç–µ–º–µ
        # –ù–∞ Windows —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —á—Ç–æ-—Ç–æ –≤—Ä–æ–¥–µ "C:\Program Files\LibreOffice\program\soffice.exe"
        # –ù–∞ Linux/macOS —á–∞—Å—Ç–æ –ø—Ä–æ—Å—Ç–æ "soffice" –∏–ª–∏ "/usr/bin/soffice"
        cmd = [
            "soffice", # –∏–ª–∏ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ –∏—Å–ø–æ–ª–Ω—è–µ–º–æ–º—É —Ñ–∞–π–ª—É soffice
            "--headless", # –ó–∞–ø—É—Å–∫ –±–µ–∑ GUI
            "--convert-to", "docx",
            "--outdir", str(output_dir),
            str(doc_path)
        ]
        logging.info(f"Attempting to convert DOC to DOCX: {' '.join(cmd)}")

        # –ó–∞–ø—É—Å–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
        result = subprocess.run(cmd, capture_output=True, text=True, check=False) # check=False, —á—Ç–æ–±—ã –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫–∏ –≤—Ä—É—á–Ω—É—é

        if result.returncode == 0 and output_path.exists():
            logging.info(f"Successfully converted {doc_path} to {output_path}")
            return str(output_path)
        else:
            logging.error(f"Failed to convert {doc_path}.")
            logging.error(f"Return Code: {result.returncode}")
            logging.error(f"Stderr: {result.stderr}")
            logging.error(f"Stdout: {result.stdout}")
            # –ü–æ–ø—ã—Ç–∫–∞ —É–¥–∞–ª–∏—Ç—å –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–π –≤—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª
            if output_path.exists():
                try:
                    os.remove(output_path)
                except OSError as rm_err:
                    logging.warning(f"Could not remove potentially incomplete output file {output_path}: {rm_err}")
            return None

    except FileNotFoundError:
        logging.error("`soffice` command not found. Is LibreOffice installed and in the system's PATH?")
        return None
    except Exception as e:
        logging.error(f"Error during DOC to DOCX conversion for {doc_path}: {e}")
        return None

def extract_markdown_from_doc(doc_path: str) -> Optional[str]:
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç DOC —Ñ–∞–π–ª: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –≤ DOCX, –∑–∞—Ç–µ–º –∏–∑–≤–ª–µ–∫–∞–µ—Ç Markdown.
    """
    with tempfile.TemporaryDirectory() as temp_dir:
        converted_docx_path = convert_doc_to_docx(doc_path, temp_dir)
        if converted_docx_path:
            try:
                markdown_text = extract_markdown_from_docx(converted_docx_path)
                # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: —É–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π docx —Ñ–∞–π–ª –º–æ–∂–Ω–æ –∏ –Ω–µ –¥–µ–ª–∞—Ç—å,
                # —Ç–∞–∫ –∫–∞–∫ –≤—Å—è –ø–∞–ø–∫–∞ temp_dir –±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.
                return markdown_text
            except Exception as e:
                 logging.error(f"Failed to extract markdown from converted DOCX ({converted_docx_path}): {e}")
                 return None # –í–æ–∑–≤—Ä–∞—â–∞–µ–º None –ø—Ä–∏ –æ—à–∏–±–∫–µ –Ω–∞ —ç—Ç–∞–ø–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–∑ DOCX
        else:
            logging.error(f"Conversion failed for {doc_path}. Cannot extract markdown.")
            return None # –í–æ–∑–≤—Ä–∞—â–∞–µ–º None, –µ—Å–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å


# --- –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è-–¥–∏—Å–ø–µ—Ç—á–µ—Ä ---

def process_document(file_path: str) -> Optional[str]:
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É (PDF, DOCX, DOC), –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—Å—Ç
    –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –µ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ Markdown.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç None –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –∏–ª–∏ –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞.
    """
    path = Path(file_path)
    if not path.is_file():
        logging.error(f"File not found: {file_path}")
        return None

    file_ext = path.suffix.lower()
    markdown_content = None

    try:
        if file_ext == ".pdf":
            markdown_content = extract_markdown_from_pdf_with_tables(str(path))
        elif file_ext == ".docx":
            markdown_content = extract_markdown_from_docx(str(path))
        elif file_ext == ".doc":
            markdown_content = extract_markdown_from_doc(str(path))
        else:
            logging.warning(f"Unsupported file format: {file_ext} for file {file_path}")
            return None

        if markdown_content is None:
             logging.warning(f"Extraction resulted in None for file: {file_path}")

        return markdown_content

    except Exception as e:
        logging.error(f"An unexpected error occurred while processing {file_path}: {e}")
        return None # –í–æ–∑–≤—Ä–∞—â–∞–µ–º None –ø—Ä–∏ –ª—é–±–æ–π –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–π –æ—à–∏–±–∫–µ

#file_path = "D:\\BOT\\data\\contexts\\866070767\\test\\documents\\test_pdf.pdf"
#extracted_text = process_document(file_path)
#
#print("====================# –ò–∑–≤–ª–µ—á–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç #====================")
#print(extracted_text)
#print("=============================================================")
#
#txt_file_path = "D:\\BOT\\data\\contexts\\866070767\\test\\text\\test_pdf.txt"
#with open(txt_file_path, 'w', encoding="utf-8") as txt_out_file:
#    txt_out_file.write(extracted_text)


** –§–∞–π–ª moduls\lightrag_module.py**
from lightrag import LightRAG, QueryParam
from lightrag.llm.openai import openai_complete_if_cache
from lightrag.utils import setup_logger, EmbeddingFunc
from lightrag.llm.hf import hf_embed
from lightrag.kg.shared_storage import initialize_pipeline_status

# –í–æ–∑–º–æ–∂–Ω–æ, –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å initialize_pipeline_status, –µ—Å–ª–∏ –æ–Ω–æ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ
# from lightrag.kg.shared_storage import initialize_pipeline_status

from transformers import AutoModel, AutoTokenizer
import asyncio # asyncio –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω –∑–¥–µ—Å—å –¥–ª—è run
import numpy as np
from config import LLM_API_KEY, LLM_BASE_URL, MODEL_NAME, MAX_TOKEN_SIZE_EMBED, EMBED_TOKENIZER_NAME

setup_logger("lightrag", level="INFO")

# –°–¥–µ–ª–∞—Ç—å build_rag –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π
async def build_rag(storage_dir: str):

    # –û–ø—Ä–µ–¥–µ–ª–∏–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –º–æ–¥–µ–ª–∏ LLM, –∫–∞–∫ –∏ –±—ã–ª–æ
    async def llm_model_func(
            prompt, system_prompt=None, history_messages=[], keyword_extraction=False, **kwargs) -> str:
        return await openai_complete_if_cache(
            MODEL_NAME,
            prompt,
            system_prompt=system_prompt,
            api_key=LLM_API_KEY,
            history_messages=history_messages,
            base_url=LLM_BASE_URL,
            **kwargs
        )

    # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä LightRAG
    rag = LightRAG(
        working_dir=storage_dir,
        llm_model_func=llm_model_func, # –ü–µ—Ä–µ–¥–∞–µ–º async —Ñ—É–Ω–∫—Ü–∏—é
        llm_model_name=MODEL_NAME,
        embedding_func=EmbeddingFunc(
            embedding_dim=1024,
            max_token_size=MAX_TOKEN_SIZE_EMBED,
            func=lambda texts: hf_embed( # –£–±–µ–¥–∏—Å—å, —á—Ç–æ hf_embed –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤ async –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ (–æ–±—ã—á–Ω–æ –¥–∞)
                texts,
                tokenizer=AutoTokenizer.from_pretrained(
                    EMBED_TOKENIZER_NAME, device_map="auto"
                ),
                embed_model=AutoModel.from_pretrained(
                    EMBED_TOKENIZER_NAME, device_map="auto"
                ),
            ),
        ),
    )

    # –ù–∞–ø—Ä—è–º—É—é –≤—ã–∑—ã–≤–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    await rag.initialize_storages()
    await initialize_pipeline_status()

    # –ï—Å–ª–∏ initialize_pipeline_status –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è, –∏—Å–ø–æ–ª—å–∑—É–π await
    # await initialize_pipeline_status()
    # –ï—Å–ª–∏ –æ–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è, –≤—ã–∑—ã–≤–∞–π –∫–∞–∫ –æ–±—ã—á–Ω–æ:
    # initialize_pipeline_status()
    # –í —Ç–≤–æ–µ–º –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ –æ–Ω–∞ –≤—ã–∑—ã–≤–∞–ª–∞—Å—å –≤–Ω—É—Ç—Ä–∏ async —Ñ—É–Ω–∫—Ü–∏–∏, —Ç–∞–∫ —á—Ç–æ —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –æ–Ω–∞ async:
    # –ü—Ä–æ–≤–µ—Ä—å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é/–∏—Å—Ö–æ–¥–Ω–∏–∫–∏ LightRAG –¥–ª—è initialize_pipeline_status
    # –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, —á—Ç–æ –æ–Ω–∞ async:
    # await initialize_pipeline_status() # <--- –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π, –µ—Å–ª–∏ –æ–Ω–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ async

    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç rag
    return rag

# –£–±–∏—Ä–∞–µ–º –≤–ª–æ–∂–µ–Ω–Ω—É—é initialize_rag –∏ –≤—ã–∑–æ–≤ asyncio.run

**–§–∞–π–ª bot.py**
import logging
import asyncio
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import BotCommand

from config import BOT_TOKEN
from handlers.start import router as start_router  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º router –∏–∑ start.py
from handlers.context import router as context_router  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º router –∏–∑ context.py
from handlers.document import router as document_router  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º router –∏–∑ document.py
from handlers.question import router as question_router  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º router –∏–∑ question.py
from handlers.main_menu import router as main_menu_router # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º router –∏–∑ main_menu.py

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
async def main():
    bot = Bot(token=BOT_TOKEN)
    dp = Dispatcher(storage=MemoryStorage())

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    dp.include_routers(start_router,
                       context_router,
                       document_router,
                       question_router,
                       main_menu_router)

    # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–º–∞–Ω–¥ –¥–ª—è –±–æ—Ç–∞
    commands = [
        BotCommand(command="start", description="–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞"),
    ]
    await bot.set_my_commands(commands)

    # –ù–∞—á–∞–ª–æ –æ–ø—Ä–æ—Å–∞
    await dp.start_polling(bot)

    # –ó–∞–∫—Ä—ã—Ç–∏–µ —Å–µ—Å—Å–∏–∏ –±–æ—Ç–∞
    await bot.close()

if __name__ == "__main__":
    asyncio.run(main())
